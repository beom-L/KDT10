## ---------------------------------------------------------------
## 클래스 정의
## - 사물이 가진 고유의 특징(외형, 성질, 기능, 역할)을 묶어 놓은 정의서
## - 클래스를 기반으로 메모리 힙 영역에 저장됨
## - 구성 : 속성/필 드 --- 데이터 즉, 변수
##         기능/메서드 --- 함수
## ---------------------------------------------------------------
## 클래스 정의 : 자동차를 정의/표현하는 타입
## 클래스 이름 : Car
## 속      성 : 바퀴, 차번호, 색상, 종류, 주유, 무게, 길이, 너비
## 메  서  드 : 전진한다, 후진한다, 정지한다
## ---------------------------------------------------------------
class Car :  ## self는 클래스 안에서만 사용
    ## -------------------------------------------------------
    # - 자동차 속성/데이터 중 공통/공유되는 속성들 : 클래스 속성/변수
    # - 사용법 : 클래스이름.클래스변수
    # -         객체/인스턴스변수명.클래스변수
    ## -------------------------------------------------------
    weight = 1600  ## 얘는 self를 안쓰는 이유가, self는 해당 클래스의 주소에 저장하기 위함임. 근데 얘는 전역변수니깐 다 같이 하나의 주소를 공유하기에 굳이 self x
    height = 700
    width  = 1000

    ## ---------------------------------------------------
    # - 객체/인스턴스 메모리 힙 저장 위한 메모리 스캔 및 할당 
    # - __init__() 메서드 호출함
    # - 매개변수 
    #      cls: 클래스 정보가 전단됨
    ## ---------------------------------------------------
    # def __new__(cls, **args):  ## 추가로 new를 안적는 이유는, 이미 클래스를 호출할 때 상속받은 클래스라서 굳이 적지않음 
    #     print('__new__()')
    #     obj = super().__new__(cls) ## 부모는 super class라고 부름 / 자식은 sub class 라고 부름
    #     print(f'obj => {id(obj)}')
    #     return obj

    ## ---------------------------------------------------
    # - 객체/인스턴스 속성 초기화 메서드  
    # - 클래스이름() 메서드 즉, 생성자 메서드와 연결
    ## ---------------------------------------------------
    ## init이 없으면 부모인 object로 찾아가고, object안에 있는 init을 실행시킴.
    ## 그래서 내가 사용할려면 안에 만들어줘야됨

    ## - 객체/인스턴스마다 고유의 값을 가지는 속성/변수 : 인스턴스 속성/변수 라고함
    def __init__(self, car_no, color, car_type, kind, weight, height, width):          ## 앞뒤로 __있으면 magic 메서드라고 부름  
        print('__init__()')
        print(f'self => {id(self)}')
        self.car_no = car_no   ## self 는 데이터가 1000번지 인건아는데, 1000번지 데이터 어디에 red가 저장된지 모름. 그래서 self라는 변수에 저장해놓는거임
        self.color = color
        self.car_type = car_type
        self.kind = kind


    ## -----------------------------------------------
    # - 인스턴스 메서드
    # - 인스턴스 속성들을 사용하는 메서드
    # - 인스턴스 생성해야만 사용가능한 메서드
    ## -----------------------------------------------
    def go(self, where):           ## 여기에 self를 넣는 이유 -> 어떤 클래스든, 똑같이 사용할 메소드니깐 해당 클래스를 호출할때만 함수를 호출하기위함
        # 000 자동차가 앞으로 간다
        print(f'{self.car_no} 자동차가 {where}로 간다.')
        print(f'{self.color} 자동차가 {where}로 간다.')
    def back(self): 
        print(f'{self.car_no} 자동차가 후진.')
        print(f'{self.color} 자동차가 후진.')
    def stop(self): 
        print(f'{self.car_no} 자동차가 정지.')
        print(f'{self.color} 자동차가 정지.') 


## ---------------------------------------------------------------
## 클래스 기반 객체/인스턴스 생성 : 생성자(Constructor) 메서드 [클래스 이름이랑 똑같이 사용]
## - 문법 : 변수명 = 클래스이름()   <- 이게 객체 만드는거임
## ---------------------------------------------------------------
myCar = Car('12가 1212','red','하이브리드','새단', 16000,700,1000)
herCar = Car('254가 3212','black','전기','새단', 16000,700,1000)
hisCar = Car('24와 3412','yellow','가솔린','새단', 16000,700,1000)

'''
내부적으로 발생하는 과정
-> (1) __new__() 호출 
    * 메모리 힙에 Car 클래스의 속성과 메서드 저장 가능 공간 스캔
    * 메모리 힙의 주소를 self 저장해서 전달 => __init__(self)
-> (2) __init__(self) 호출
    * 전달 받은 self를 사용해서 지정된 메모리 힙에 저장 및 초기화 진행
'''
myCar.__new__



## ---------------------------------------------------------------
## 객체/인스턴스 속성 및 메서드 사용
## - 문법 : 객체/인스턴스_변수명.속성명
##          객체/인스턴스_변수명.속성명()
## ---------------------------------------------------------------
myCar.go('바다')
hisCar.go('도시')